# Java类加载器

## ClassLoader 简介

一个完整的 Java 应用程序由若干个 Java Class 文件组成，当程序在运行时，会通过一个入口函数来调用系统的各个功能，这些功能都被存放在不同的 Class 文件中。

因此，系统在运行时经常会调用不同 Class 文件中被定义的方法，如果某个 Class 文件不存在，则系统会抛出 ClassNotFoundException 异常。

系统程序在启动时，不会一次性加载所有程序要使用的 Class 文件到内存中，而是根据程序需要，通过 Java 的类加载机制动态将需要使用的 Class 文件加载到内存中; 只有当某个 Class 文件被加载到内存后，该文件才能被其他 Class 文件调用。

**这个 "类加载机制" 就是 ClassLoader , 他的作用是动态加载 Java Class 文件到 JVM 的内存空间中，让 JVM 能够调用并执行 Class 文件中的字节码**。

## ClassLoader 分类

- **JVM 默认类加载器**
  主要由 “引导类加载器(根加载器)”、“扩展类加载器”、“系统类加载器(默认)” 三方面组成。
- **用户自定义类加载器**
  用户可以编写继承 java.lang.ClassLoader类的自定义类来自定义类加载器。

**类加载器的定义声明在`%JAVA_HOME%/lib/rt.jar/sun/Launch.class`，它是JVM的入口。**

### 引导类加载器（BootstrapClassLoader）

BootstrapClassLoader 负责加载 JVM 运行时核心类，它负责索引环境变量`%JAVA_HOME%/jre/lib`下的所有核心类jar包和class文件。**Bootstrap ClassLoader是由C/C++编写的，是JVM的一部分，并不是一个Java类。不继承 java.lang.ClassLoader 类，也没有父类加载器。**

### 扩展类加载器（ExtensionsClassLoader）

ExtensionClassLoader负责**加载标准核心Java类的扩展**，索引环境变量`%JAVA_HOME%/jre/lib/ext`下的所有扩展类jar包和class文件，这些扩展包通常以`javax`开头。**为了方便简写为ExtClassLoader。**

### 系统类加载器（AppClassLoader）

AppClassLoader负责索引环境变量`%CLASSPATH%`下的 jar 包和class文件。**如果不声明类加载器，它是默认的类加载器。**

## 类加载器核心方法

1. `loadClass`（加载指定的Java类）
2. `findClass`（查找指定的Java类）
3. `findLoadedClass`（查找JVM已经加载过的类）
4. `defineClass`（定义一个Java类）
5. `resolveClass`（链接指定的Java类）

## 类加载器流程

### 类加载器顺序

从运行开始，类加载器按照以下顺序加载类

1. BootstrapClassLoader
2. ExtClassLoader
3. AppClassLoader

```java
Public class Test{
 
    Public static void main(String[] arg){
 
      ClassLoader c  = Test.class.getClassLoader();  //获取Test类的类加载器
 
        System.out.println(c); 
 
      ClassLoader c1 = c.getParent();  //获取c这个类加载器的父类加载器
 
        System.out.println(c1);
 
      ClassLoader c2 = c1.getParent();//获取c1这个类加载器的父类加载器
 
        System.out.println(c2);
 
  }
 
}
```

运行结果

![image-20220205215800889](https://cosmoslin.oss-cn-chengdu.aliyuncs.com/img2/image-20220205215800889.png)

### 双亲委派机制

![img](https://www.guildhab.top/wp-content/uploads/2021/03/2021-03-24_15-33.png)

1. 首先检测该类是否被加载，如果被加载直接返回该类
2. 如果未被加载，检测是否声明了父加载器，如果声明类父加载器则使用父加载器加载它
3. 如果未被加载，也未声明父加载器，再次尝试用根加载器加载它
4. 如果根加载器也无法加载，再使用该加载器自身加载

#### 优点

- 避免类的重复加载， 确保一个类的全局唯一性
- 保护程序安全， 防止核心 API 被随意篡改

#### 缺点

- 父加载器无法访问子加载器所加载的类

## 自定义类加载器

因为自带的类加载器只能从指定的环境变量加载，而非环境变量路径的加载就需要自定义类加载器来实现。
自定义类加载器的条件

编写自定义类加载器需要继承ClassLoader类，需要涉及以下两个重要的方法：

    findClass()，自定义加载器自己的加载方法，如果父加载器都无法加载时调用，需要重写，该方法的目的是获取class字节码
    defineClass()，在findClass()内调用，用于组装class对象

另外，自定义类加载器不要轻易覆盖loadClass()方法，否则可能会导致自定义加载器无法加载核心类库。在使用自定义加载器时，要明确好它的父加载器是谁，将父加载器通过子类的构造器传入，如果缺省，父加载器是App。

### 弹计算器

```java
package evil;

import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.NotFoundException;

import java.io.IOException;
import java.lang.reflect.Method;

public class MyClassLoader extends ClassLoader {
    public static String className = "evil.Testt";
    public  byte[] classBytes = new byte[]{-54,-2,-70,-66,0,0,0,51,0,56,10,0,11,0,30,10,0,31,0,32,8,0,33,10,0,31,0,34,7,0,35,10,0,5,0,36,9,0,37,0,38,8,0,39,10,0,40,0,41,7,0,42,7,0,43,1,0,6,60,105,110,105,116,62,1,0,3,40,41,86,1,0,4,67,111,100,101,1,0,15,76,105,110,101,78,117,109,98,101,114,84,97,98,108,101,1,0,18,76,111,99,97,108,86,97,114,105,97,98,108,101,84,97,98,108,101,1,0,4,116,104,105,115,1,0,12,76,101,118,105,108,47,84,101,115,116,116,59,1,0,4,67,97,108,99,1,0,1,101,1,0,21,76,106,97,118,97,47,105,111,47,73,79,69,120,99,101,112,116,105,111,110,59,1,0,13,83,116,97,99,107,77,97,112,84,97,98,108,101,7,0,35,1,0,4,109,97,105,110,1,0,22,40,91,76,106,97,118,97,47,108,97,110,103,47,83,116,114,105,110,103,59,41,86,1,0,4,97,114,103,115,1,0,19,91,76,106,97,118,97,47,108,97,110,103,47,83,116,114,105,110,103,59,1,0,10,83,111,117,114,99,101,70,105,108,101,1,0,10,84,101,115,116,116,46,106,97,118,97,12,0,12,0,13,7,0,44,12,0,45,0,46,1,0,4,99,97,108,99,12,0,47,0,48,1,0,19,106,97,118,97,47,105,111,47,73,79,69,120,99,101,112,116,105,111,110,12,0,49,0,13,7,0,50,12,0,51,0,52,1,0,3,49,50,51,7,0,53,12,0,54,0,55,1,0,10,101,118,105,108,47,84,101,115,116,116,1,0,16,106,97,118,97,47,108,97,110,103,47,79,98,106,101,99,116,1,0,17,106,97,118,97,47,108,97,110,103,47,82,117,110,116,105,109,101,1,0,10,103,101,116,82,117,110,116,105,109,101,1,0,21,40,41,76,106,97,118,97,47,108,97,110,103,47,82,117,110,116,105,109,101,59,1,0,4,101,120,101,99,1,0,39,40,76,106,97,118,97,47,108,97,110,103,47,83,116,114,105,110,103,59,41,76,106,97,118,97,47,108,97,110,103,47,80,114,111,99,101,115,115,59,1,0,15,112,114,105,110,116,83,116,97,99,107,84,114,97,99,101,1,0,16,106,97,118,97,47,108,97,110,103,47,83,121,115,116,101,109,1,0,3,111,117,116,1,0,21,76,106,97,118,97,47,105,111,47,80,114,105,110,116,83,116,114,101,97,109,59,1,0,19,106,97,118,97,47,105,111,47,80,114,105,110,116,83,116,114,101,97,109,1,0,7,112,114,105,110,116,108,110,1,0,21,40,76,106,97,118,97,47,108,97,110,103,47,83,116,114,105,110,103,59,41,86,0,33,0,10,0,11,0,0,0,0,0,3,0,1,0,12,0,13,0,1,0,14,0,0,0,47,0,1,0,1,0,0,0,5,42,-73,0,1,-79,0,0,0,2,0,15,0,0,0,6,0,1,0,0,0,5,0,16,0,0,0,12,0,1,0,0,0,5,0,17,0,18,0,0,0,1,0,19,0,13,0,1,0,14,0,0,0,107,0,2,0,2,0,0,0,18,-72,0,2,18,3,-74,0,4,87,-89,0,8,76,43,-74,0,6,-79,0,1,0,0,0,9,0,12,0,5,0,3,0,15,0,0,0,22,0,5,0,0,0,8,0,9,0,11,0,12,0,9,0,13,0,10,0,17,0,12,0,16,0,0,0,22,0,2,0,13,0,4,0,20,0,21,0,1,0,0,0,18,0,17,0,18,0,0,0,22,0,0,0,7,0,2,76,7,0,23,4,0,9,0,24,0,25,0,1,0,14,0,0,0,55,0,2,0,1,0,0,0,9,-78,0,7,18,8,-74,0,9,-79,0,0,0,2,0,15,0,0,0,10,0,2,0,0,0,15,0,8,0,16,0,16,0,0,0,12,0,1,0,0,0,9,0,26,0,27,0,0,0,1,0,28,0,0,0,2,0,29};





    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        System.out.println(name);
        if (name.equals(className)) {
            return defineClass(className, classBytes, 0, classBytes.length);
        }
        return super.findClass(name);
    }

    public static void main(String[] args) throws Exception {

        MyClassLoader myClassLoader = new MyClassLoader();
        Class aClass = myClassLoader.loadClass(className);
        Object obj = aClass.newInstance();
        Method calc = obj.getClass().getMethod("Calc");
        calc.invoke(obj,null);
    }


}

```



## 类加载隔离



## BCEL 

https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html





参考：

https://blog.csdn.net/Xxy605/article/details/121332763
